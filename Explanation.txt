I was unable to complete Programming Assignment #1. I had several issues with the assignment, and in
this file I will give explanations as to what happened my end and finish with my own personal detailed
walkthrough of how I believe the code should work, what was needed and how each individual piece worked.

Part 1: The environment
One of the first issues I had was getting the proper environment to code in. I had heard from a couple
students that you were able to run Linux/Unix commands in Visual Studio Code, so that was the first
IDE I tried since I was very familiar with Visual Studio from classes in the past. I installed minGW
and followed the video tutorial you sent us to install the pthread library for VSCode. I tried to switch
the compiler from the standard C++ compiler to minGW for Unix commands but something did not seem
correct; the terminal window had not changed, I was getting occasional errors, and couldn't get anything
to compile. It was still fairly early on in the project so I decided to try VirtualBox and get Ubuntu.
I was mildly familiar with VB, having successfully made an older Windows OS run many years ago, so I
thought I could do it again. No matter what I tried, either making one fresh with the tools that VB
gave me or downloading a couple .iso files, it never seemed to boot properly. So then I decided to try
Docker, and Docker went well enough, but before you could create an environment you had to do 3 things:
have VSCode installed, a special module for VSCode, and install Git. No matter which way I installed
Git, restarting Docker before and after installation, it refused to recognize that Git was installed on
my machine. After trying all three of those a couple more times, I decided that there was one place I
knew had Unix commands that worked, so I ssh'd into wasp/hornet, created a folder for the project, and
checked to see if the pthreads library was installed (which it was). I figured I could either locally
download my files once I was done or copy them quickly by hand into VSCode or github directly. These
issues took up approximately 3-4 days of worktime since multiple downloading .iso files on 3 MB of
internet speed took a few days.

Part 2: The coding
Once I had my environment issue figured out, I could get started on the coding proper. I made my three
files (producer.cpp, consumer.cpp, and producer-consumer.hpp in case I needed it) and was about to
begin. Here's a list of the websites I primarily focused on in my research for the project:
https://www.geeksforgeeks.org/use-posix-semaphores-c/
https://www.geeksforgeeks.org/producer-consumer-problem-using-semaphores-set-1/
https://www.geeksforgeeks.org/ipc-shared-memory/
https://www.tutorialspoint.com/inter_process_communication/inter_process_communication_shared_memory.htm
https://man7.org/linux/man-pages/man3/shm_open.3.html
https://man7.org/linux/man-pages/man7/shm_overview.7.html
https://stackoverflow.com/questions/5656530/how-to-use-shared-memory-with-linux-in-c
And a helpful video explaning semaphores: https://www.youtube.com/watch?v=NuvAjMk9bZ8
I believe that these websites give great explanations of the coding topics and concepts required for
this project, with good documentation and extensive comments. However, I feel as though many of these
sites structured their explanations with the idea that whomever was going to read them was a little
familiar with many of these libraries and their components as opposed to a basic-level tutorial.
There were many parts of certain functions that I was unsure of where they came from/how the author
decided on those particular values (for example, on https://www.geeksforgeeks.org/ipc-shared-memory/,
the function ftok is described as "is used to generate a unique key" and the function is called as:
key_t key = ftok("shmfile",65); with no mention of where "shmfile" or 65 come from or if their name or
value have significance.) I could just have been overthinking/misinterpreting things, which is
entirely possible, but as I will get to in the next part, I feel as though I understand how the
Producer-Consumer Problem needs to be solved but have no idea how to do it in code.

Part 3: The Producer-Consumer Problem
This is, in an explanation of words rather than code, how I believe the Producer-Consumer Problem
would have to be solved.
To begin, you would have to decide how the memory would be shared between producer.cpp and
consumer.cpp. It seemed like you could have a physical piece of memory, like an array/vector, or an
arbitrary piece of memory, much like the example you showed in class or shown in some of the websites
I visited. My plan was to create a dynamic array of size 2 with a pointer, and use that pointer as
the shared memory. From what I could understand, when you declare/create shared memory, you can pass
almost anything through to use as shared memory, so I would just pass the pointer and the pointer
can be used by both the producer and the consumer. Next I believe you would have to create your
semaphores, and only three should be needed: one to create mutual exclusion between producer.cpp and
consumer.cpp, one to keep track of how many empty pieces are in the table and one to keep track of
how many full pieces are in the table. From what I understand, the semaphore that creates mutual
exclusion would act as a large "iterator" in a sense: it would allow only one process to access the
shared memory at a time while also incrementing itself (called a binary semaphore I believe), so I 
could test my processes by having it "iterate" a fixed number of times, having it fill up an empty
completely. I think if I were to do an array with a pointer, I may not need the last two semaphores,
since my idea was that, I could do a for-loop and each time the producer is allowed access to the
shared memory, it would loop through the array and check to see if any of the spots in the array were
empty; if they were it would fill it again, and if not, then it would have no need to fill the table.
The only thing I will say that I do not entirely understand is how it would know to switch between
producer.cpp and consumer.cpp; I know that the semaphore would allow that but I don't know how that
would be set up. But I believe that is the general concept behind this project: start by declaring the
shared memory, create your semaphores (1-3 depending on how you use shared memory), then use the
semaphores to allow only the producer or the consumer access to the shared memory, one at a time. The
actual code for producing an item and consuming an item would be very simple: if the space in the array
at which the pointer points to is empty, the producer would fill that space in the array. If it is
full, the consumer would empty that space in the array.

Part 4: Conclusion
This was written on Monday, October 25, 2021, the day before the project is due. While I do still have
time to complete the project and will still attempt to, I have other assignments due soon and I am
a little behind on notes in this class, which I want to catch-up on since I know we have an exam
coming up soon. If I am able to successfully complete the assignment, or at least to a certain extent
am able to create code that partially executes the required function asked of this project, that code
will be uploaded to my GitHub. Otherwise this file will be the only thing in this folder besides the
README, which should lead you to this file. UPDATE: Instead of re-typing this whole paragraph, I'm
adding this footnote. I have included three pseudo-code files (producer.cpp, consumer.cpp, 
producer-consumer.cpp) that I believe outlines the proper placement, declaration, and usage of
code.
